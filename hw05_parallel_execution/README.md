## Домашнее задание №5 «Параллельное исполнение»
Необходимо написать функцию для параллельного выполнения заданий в N параллельных горутинах:
* функция должна останавливать свою работу, если произошло M ошибок;
* после завершения работы функции (успешного или из-за превышения M) не должно оставаться работающих горутин;
* если задачи работают без ошибок, то выполнятся `len(tasks)` задач (т.е. все задачи);
* если в первых M задачах происходят ошибки, то всего выполнится не более N+M задач.

Нужно учесть, что задания могут выполняться разное время, а длина списка задач
`len(tasks)` может быть больше или меньше N.

Значение M <= 0 трактуется на усмотрение программиста:
- или это знак игнорировать ошибки в принципе;
- или считать это как "максимум 0 ошибок", значит функция всегда будет возвращать 
`ErrErrorsLimitExceeded`;
- на эту логику следует написать юнит-тест.

При необходимости можно выделять дополнительные функции / ошибки.

### Критерии оценки
- Пайплайн зелёный - 4 балла
- Добавлены новые юнит-тесты - до 4 баллов
- Понятность и чистота кода - до 2 баллов

#### Зачёт от 7 баллов

### Подсказки
- https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem
- `sync.WaitGroup`
- `go test -v -race -count=100 .`

### Частые ошибки
1) `racedetector` ругается на строчку с ассертом в тестах:
- простой случай: после выхода из `Run` остаются висячие горутины, отсюда и получаем `data race` -
ассерт в тестах неатомарно обращается к `runTasksCount`, в то время как зомби-горутины атомарно пытаюся её поменять.
- случай посложнее: один тест завершается успешно, но висячие горутины, им порожденные, аффектят ассерты в
последующих тестах.

**Решение**: внимательно посмотреть места выхода из функции и гарантировать, что все порождённые вами горутины
завершились к этому моменту.

В ДЗ важно сделать так, чтобы одновременно выполнялось не больше N задач и чтобы при выходе из функции Run не осталось горутин.
Под "в N параллельных горутинах" подразумевается, что есть N консьюмеров. За счет этого и нужно ограничить одновременное выполнение не более N задач одноврменно.
Продьюсер в задаче один - функция Run.
Для передачи задач от продьюсеру консьюмера лучше всего использовать канал. Есть варианты решения как с буферизированным каналом, так и без него. Если будете делаь с буфером, то четко поймите, какую проблему он решает, и что будет, если буфер убрать.
Я видел, как буферизованный канал использовали, чтобы дождаться горутин перед выходом из Run (второе важное условие задачи). Но это были решения людей, которые не знали других примитивов синхронизации.
Есть еще и третье условие в задаче - если M джоб вернули ошибку, то надо все завершать. Тут важно не переусложнить.
Рекомендую решать задачу в три этапа:
1. Сначала разобраться, как в принципе сделать N коньюмеров и передавать им джобы.
2. Как дождаться завершения всех воркеров.
3. Как сделать так, чтобы воркеры перестали брать новые джобы, если набралось M ошибок.

но нет ожидания горутин (возможно, у вас не работают тесты именно для этого случая?). Если не работает какой-то другой случай, то напишите, пожалуйста, как вы проверяете (надеюсь, что тестами :)).

PS. В коде есть ошибка с закрытием errChan. В него пишут в другой горутине, которая на момент закрытия канала еще может работать.